FOLDER STRUCTURE EXPLAINED :

1. The outer PollApp directory is just the container for the project. Its name doesn't matter to Django; you can rename it to anything you like.
2. manage.py :  A command-line utility that lets you interact with this Django project in various ways.
3. The inner PollApp/ directory is the actual Python package for your project. Its name is the Python package name you’ll need to use to import anything
   inside it (e.g. PollApp.urls).
4. PollApp/__init__.py: An empty file that tells Python that this directory should be considered a Python package. 
5. PollApp/settings.py: Settings/configuration for this Django project.
6. PollApp/urls.py: The URL declarations for this Django project; a “table of contents” of your Django-powered site. 
7. PollApp/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project.

TO CREATE A PROJECT FROM THE COMMAND LINE :

django-admin.py startproject PollApp

This command will generate the folder structure as explained above. Since I am using the pyDev library for eclipse, this structure is generated by 
the eclipse itself. 

TO CHECK WETHER THE DEVELOPMENT SERVER IS WORKING OR NOT :

python manage.py runserver 8000

After running this command, type in your browser localhost:8000, and you will see a HTTP get request received by the server

DATABASE SETUP

1. Goto PollApp/settings.py
2. By default it uses the SQLlite3.
3. Depending on what database to use, the DATABASE 'default' field needs to be changed.
    ENGINE – 'django.db.backends.sqlite3',
    		 'django.db.backends.postgresql_psycopg2',
    		 'django.db.backends.mysql',
    		 'django.db.backends.oracle'. 
    		 
    NAME – The name of your database. In case of SQLlite3, the database will be a file on your computer. Hence the name should indicate the absolute path
    of the database file i.e. os.path.join(BASE_DIR, 'db.sqlite3'). This will store the file in your project directory.

NOTE: if we are using database except SQLlite2, we need to explicitly create a database by this point.


python manage.py migrate(syncdb)

This command checks for the installed apps in the INSTALLED_APPS section of the settings.py, and then creates all the necessary tables required by these apps.

python manage.py startapp polls

This command will create a directory polls with the following structure.

	polls/
   		 __init__.py
    	 admin.py
     	 models.py
    	 tests.py
    	 views.py

This directory structure will house our poll Application.

The first step we will do is to define the models that our application is going to use. A Model is basically a single file, that stores data about the 
data (metadata). 

NOTE: Django follows the DRY principle.

DRY: Every distinct concept and/or piece of data should live in one, and only one, place. Redundancy is bad. Normalization is good.

We now create two models namely:

	QUESTION			CHOICE
		question_text		choice_text
		pub_date			vote_tally
		
Since each choice must be associated with a question, we need to create a foreign key(question) that refers to the question model. Eg:

from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    question = models.ForeignKey(Question)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)			
    
------------------------------------------------------------------------------------------------    
Different Fields

1. CharField

	class CharField(max_length=None[, **options])

	a. A string field, for small- to large-sized strings.
	b. For large amounts of text, use TextField.
	c. The default form widget for this field is a TextInput.

	CharField has one extra required argument:

		CharField.max_length
   	d. The maximum length (in characters) of the field. The max_length is enforced at the database level and in Django’s validation.
    
2. BooleanField

	class BooleanField(**options)

	a. A true/false field.
	b. The default form widget for this field is a CheckboxInput.
	c. If you need to accept null values then use NullBooleanField instead.  
	
3. CommaSeparatedIntegerField

	class CommaSeparatedIntegerField(max_length=None[, **options])

	a. A field of integers separated by commas. As in CharField, the max_length argument is required and the note about database
	portability mentioned there should be heeded.	
	
4. BinaryField

	class BinaryField([**options])
	
	a. New in Django 1.6.
	b. A field to store raw binary data. It only supports bytes assignment. Be aware that this field has limited functionality. 
	For example, it is not possible to filter a queryset on a BinaryField value.
	
5. BigIntegerField

	class BigIntegerField([**options])

	A 64 bit integer, much like an IntegerField except that it is guaranteed to fit higher range of numbers.
	The default form widget for this field is a TextInput.	
	
6. 	DateTimeField

	class DateTimeField([auto_now=False, auto_now_add=False, **options])
	
	A date and time, represented in Python by a datetime.datetime instance.
	
	a. DateField.auto_now
    Automatically set the field to now every time the object is saved. Useful for “last-modified” timestamps.
    
    b. DateField.auto_now_add
    Automatically set the field to now when the object is first created. Useful for creation of timestamps.
    
    c. The default form widget for this field is a single TextInput.
    
7.   DecimalField
  
     class DecimalField(max_digits=None, decimal_places=None[, **options])

	 a. max_digits =  total number of digits allowed.
	 b. decimal_places = total number of digits after decimal.
	 
8.	 EmailField

	 class EmailField([max_length=75, **options])
	 The widget is a textbox that checks for valid email addresses.
	 
We will continue with the rest of the fields later ........

Now the polls app is created in a directory that is a sibling of the Python package PollApp. But this polls app will not run
since it is not identified in the settings.py. So we need to add 'polls' to this file.

$ python manage.py sql polls

This command will output the SQL syntax of creating the tables mentioned in the 'models.py' file of the 'polls' app 	 

Naming convention followed in the syntax

	Table Name : appName_tolower(modelName)
	Field Name : "id" -> by default created for each table.
		         "fieldName_id" -> foreign key field that references another model
		         "fieldName"
		         
The naming convention changes depending on the database we are using.

NOTE : python manage.py sql polls does not add the tables to the databases. It just displays the syntax. So, for adding the tables
to the database we need to run the command mention above, again.
		           	
python manage.py migrate(syncdb)

------------------------------------------------------------------------------------------------

python manage.py shell

This is a interactive shell API provided by Django,  	  	

------------------------------------------------------------------------------------------------


If I do Question.objects.all() this will not return me any useful information, even if the object is created. We need to use __unicode__() function instead

def __unicode__(self):
        return self.question_text
        
Following is the Django specific timezone. The django.utils.timezone provides a now() function that returns a naive or aware datetime object
according to the value of USE_TZ(in settings.py).    
    
	from django.utils import timezone 
	
When time zone support is 'disabled', Django uses naive datetime objects in local time. This is simple and sufficient for many use cases.
In this mode, to obtain the current time, you would write:	 

	 import datetime
     now = datetime.datetime.now()
     
When time zone support is 'enabled', Django uses time-zone-aware datetime objects. If your code creates datetime objects, they should be aware too.
In this mode, the example above becomes:     
	 
	 import datetime
	 from django.utils.timezone import utc

	 now = datetime.datetime.utcnow().replace(tzinfo=utc)
	 
Also one more function from the datetime package of python

 datetime.timedelta(days=no_of_days)
 
This function is used to find the difference between two dates
eg : datetime.datetime.now - datetime.timedelta(days=no_of_days)


FIELD LOOKUPS

1. startswith

	Case-sensitive starts-with.
	Example:
		Entry.objects.filter(headline__startswith='Will')
	SQL equivalent:
		SELECT ... WHERE headline LIKE 'Will%';
	
SQLite doesn’t support case-sensitive LIKE statements; startswith acts like istartswith for SQLite.

For complete list refer to the following link
https://docs.djangoproject.com/en/dev/ref/models/querysets/

Another example for year lookup

Question.objects.filter(pub_date__year = timezone.now().year)

Note: lookup by a primary key -> Question.objects.get(pk=1)

---------------------------------------------------------------------------------------------------------------------------------
Delete an entry in database

p = Question.objects.filter(id=1)
p.delete()

---------------------------------------------------------------------------------------------------------------------------------

Two ways to create the secondary table fields

1. In this way, we need not use the save() function to save the data into database

p.choice_set.create(choice_text = "red", votes = 0)
p.choice_set.create(choice_text = "blue", votes = 0)
p.choice_set.create(choice_text = "green", votes = 0)

2. remember _id appended to the question field in choice model 

q = Choice(question_id=1,choice_text = "orange", votes=0)
q.save()

---------------------------------------------------------------------------------------------------------------------------------

PART II

1. First run manage.py runserver
then open http://localhost:8000/admin
this opens up the admin page 

2. Make the poll app modifiable in the admin.
 a. But where’s our poll app? It’s not displayed on the admin index page.
 b. Just one thing to do: we need to tell the admin that Question objects have an admin interface. To do this, open the polls/admin.py file, 
	and edit it to look like this:

	from django.contrib import admin
	from polls.models import Poll

	admin.site.register(Poll)

The second argument of this function is the default AdminModel. We will now create our own admin model as follows. The model which we are making should
extend the default Admin Model.

from django.contrib import admin
from polls.models import Question

class QuestionAdmin(admin.ModelAdmin):
    fields = ['pub_date', 'question_text']

admin.site.register(Poll, QuestionAdmin)

This is how we create the field sets

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
                 ('Published Poll', {'fields' : ['question_text']}),
                 ('Date Information', {'fields' : ['pub_date']}),
                ]

admin.site.register(Question, QuestionAdmin)

Now we can add the Choice model to the Admin page. Two ways:

a. admin.site.register(Choice). This way we get the page for adding new choices. We can enter the choice and 
   select the question from the <select> box. But this approach is inefficient because, we can create a
   Question from that page, that will be added to the database, and the new question will appear in the
   choice form page. 
b. remove the register method for Choice
   
from django.contrib import admin
from polls.models import Choice, Question

class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)

Customize the admin change list

By default, Django displays the str() of each object. But sometimes it’d be more helpful if we could display
individual fields. To do that, use the list_display admin option, which is a tuple of field names to display, 
as columns, on the change list page for the object: 

    class PollAdmin(admin.ModelAdmin):
  	  # ...
   	  list_display = ('question', 'pub_date', 'was_published_recently')
   	  
You can click on the column headers to sort by those values – except in the case of the was_published_recently header, because sorting by the output 
of an arbitrary method is not supported.   	  

Right now the header of 'was_recently_published' is 'was_recently_published'. We can change that as follows:

class Poll(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
    was_published_recently.admin_order_field = 'pub_date'
    was_published_recently.boolean = True
    was_published_recently.short_description = 'Published recently?'

ADDING A FILTER

list_filter = ['pub_date']

ADDING A SEARCH FUNCTIONALITY

search_fields = ['question_text']

CUSTOMIZING YOUR PROJECT TEMPLATE

Templates can live anywhere on your file system that Django can access. However, keeping your templates within
the project is a good convention to follow.

Open your settings file (mysite/settings.py, remember) and add a TEMPLATE_DIRS setting:
TEMPLATE_DIRS = [os.path.join(BASE_DIR, 'templates')]


Customizing your application’s templates

Now one question arises. If the TEMPLATE_DIRS was not set already in the settings.py, how were the templates 
found initially in the django project?. The point is, the Django searches for the template/ subdirectory within
each application package.

So there are two types: application package and Django project. PollApp is the Django project and 
Django.contrib.admin is application package. Right now we are overriding the definition of base.html in out 
Django project, but in some other cases we can modify the application package templates directly so that the 
custom templates are available if needed.

-----------------------------------------------------------------------------------------------------------------------

PART III

In our poll application, we’ll have the following four views:

    Poll “index” page – displays the latest few polls.
    Poll “detail” page – displays a poll question, with no results but with a form to vote.
    Poll “results” page – displays results for a particular poll.
    Vote action – handles voting for a particular choice in a particular poll.


Write your first view

Let’s write the first view. Open the file polls/views.py and put the following Python code in it:

	from django.http import HttpResponse
	def index(request):
    	return HttpResponse("Hello, world. You're at the poll index.")
    	
This is the simplest view possible in Django. To call the view, we need to map it to a
URL - and for this we need a URLconf.    	

VERY IMPORTANT

(?P<poll_id>\d+). Using parentheses around a pattern “captures” the text matched by that pattern and 
sends it as an argument to the view function; ?P<poll_id> defines the name that will be used to identify
the matched pattern; and \d+ is a regular expression to match a sequence of digits (i.e., a number). 

NOTE
Each view should return either the HTTP Response or the 404 exception. Rest of the functionality is up to you

 
Create a template in polls directory. Then create polls inside it. Then index.html

{% if latest_poll_list %}
    <ul>
    {% for poll in latest_poll_list %}
        <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}

views.py

def index(request):
    poll_list = Question.objects.order_by('-pub_date') #[:5]
    template = loader.get_template('polls/index.html')
    context = RequestContext(request, {
        'latest_poll_list': poll_list,
    })
    return HttpResponse(template.render(context))   	
    
OR ANOTHER SIMPLE WAY

from django.shortcuts import render

from polls.models import Poll

def index(request):
    latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]
    context = {'latest_poll_list': latest_poll_list}
    return render(request, 'polls/index.html', context)     
    
Removing hardcoded URLs in templates

Remember, when we wrote the link to a poll in the polls/index.html template, the link was partially 
hardcoded like this:

		<li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>

The problem with this hardcoded, tightly-coupled approach is that it becomes challenging to change 
URLs on projects with a lot of templates. However, since you defined the name argument in the url() 
functions in the polls.urls module, you can remove a reliance on specific URL paths defined in your url configurations by using the {% url %} template tag:

<li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

NAMESPACING

very important topic. Suppose there are many apps in a Django project instead of one(polls). And many of them 
have a template named detail.html. And I write
 
 {% url 'detail' poll.id %}
 
Now, which detail does it refer to? To resolve such issues we use Namespaces. Edit the urls.py in PollApp 
project as follows.

from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    url(r'^polls/', include('polls.urls', namespace="polls")),
    url(r'^admin/', include(admin.site.urls)),
) 
     
And then edit the link as follows
	{% url 'polls:detail' poll.id %}

------------------------------------------------------------------------------------------------

PART 4

detail.html
	
<h1>{{ poll.question }}</h1>

{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

<form action="{% url 'polls:vote' poll.id %}" method="post">
{% csrf_token %}
{% for choice in poll.choice_set.all %}
    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br />
{% endfor %}
<input type="submit" value="Vote" />
</form>	

forloop.counter indicates how many times the for tag has gone through its loop

{% csrf_token %} prevents cross site scripting. Every POST forms targeted at an internal URL must
use this token

Now we need to update the views.py to change the contents of the function 'vote'

from django.shortcuts import get_object_or_404, render
from django.http import HttpResponseRedirect, HttpResponse
from django.core.urlresolvers import reverse
from polls.models import Choice, Poll
# ...
def vote(request, poll_id):
    p = get_object_or_404(Poll, pk=poll_id)
    try:
        selected_choice = p.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the poll voting form.
        return render(request, 'polls/detail.html', {
            'poll': p,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(p.id,)))

1. request.POST[]: this array contains all the values from the form, which the user entered or selected. These values are passed with
   Post request once the user presses the submit button.

2. request.POST['choice']: will raise a KeyError exception, if we do not receive any value in this field. In that case we render a response
   back to the details page
   
3. We have used HttpResponseRedirect instead of HttpResponse, to prevent data from being posted twice.

4. reverse():- prevents hardcoding of the links. 1st arg: name of the view. 2nd arg: the variable portion of the url that points to this view.
   reverse('polls:results', args=(p.id,))
   this is equivalent to /polls/3/results/
   
NOW THE CONTENTS OF THE results IN view.py

from django.shortcuts import get_object_or_404, render

def results(request, poll_id):
    poll = get_object_or_404(Poll, pk=poll_id)
    return render(request, 'polls/results.html', {'poll': poll})
    
results.html

<h1>{{ poll.question }}</h1>

<ul>
{% for choice in poll.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>

<a href="{% url 'polls:detail' poll.id %}">Vote again?</a>    


 vote{{ choice.votes|pluralize }} : - adds an extra 's' if the number of votes are more than 1.
 
 -------------------------------------------------------------------------------------------------------------------------
 
 PART 5
 
 AUTOMATED TESTING 
	        
 Found one error in the application
 
 Python 2.7.3 (default, Sep 26 2012, 21:51:14) 
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from polls.models import Question
>>> from django.utils import timezone
>>> import datetime
>>> p = Question(question_text="What's your age?", pub_date=timezone.now() + timezone.timedelta(days=30))
>>> q = Question.objects.all()
>>> print p
What's your age?
>>> print p.pub_date
2013-12-30 18:02:34.430502+00:00
>>> p.was_recently_published()
True
>>> 	

The Poll that will be published in the future, also returns 'was_recently_published' as true.

Open tests.py in the polls app and add the following text

import datetime

from django.utils import timezone
from django.test import TestCase

from polls.models import Poll

class PollMethodTests(TestCase):

    def test_was_published_recently_with_future_poll(self):
        """
        was_published_recently() should return False for polls whose
        pub_date is in the future
        """
        future_poll = Poll(pub_date=timezone.now() + datetime.timedelta(days=30))
        self.assertEqual(future_poll.was_published_recently(), False)

 	